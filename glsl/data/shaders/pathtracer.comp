#version 460 core
#define EPSILON     1e-6
#define PI          3.14159265359
#define TWO_PI      6.28318530718
#define MAX_BOUNCE  30

layout (local_size_x = 1, local_size_y = 1) in;
layout (rgba32f, binding = 0) uniform image2D outImage;

const float RAY_T_MIN = EPSILON;
const float RAY_T_MAX = 9999999.0;

struct Ray
{
    vec3 origin;
    float t;
    vec3 direction;
    int material;
    vec3 hitNormal;
};

struct Sphere
{
    vec3 center;
    float radius;
    int material;
};

struct Triangle
{
    vec3 A;
    float _padding0;
    vec3 B;
    float _padding1;
    vec3 C;
    int material;
};

struct Material
{
    vec3 albedo;
    float reflectChance;
    vec3 emissive;
    float roughness;
};

layout (std140, binding = 0) uniform Constant
{
    vec3 camera_origin;
    int random_seed0;
};

#define TRIANGLE_COUNT 24
layout (std140, binding = 1) uniform Triangles
{
    Triangle g_triangles[TRIANGLE_COUNT];
};

#define SPHERE_COUNT 2
const Sphere g_spheres[SPHERE_COUNT] = Sphere[SPHERE_COUNT]
(
    Sphere(vec3(-0.4, 0.5, -0.4), 0.3, 5),
    Sphere(vec3(0.4, -0.7, 0.0), 0.3, 6)
    // Sphere(vec3(+0.7, -0.7, 0.0), 0.3, 6)
);

const Material g_materials[] = Material[]
(
    // light
    Material(vec3(1.0), 0.0, vec3(10.0), 0.9),

    // red wall
    Material(vec3(0.7, 0.1, 0.1), 0.01, vec3(0.0), 0.99),

    // green wall
    Material(vec3(0.1, 0.7, 0.1), 0.01, vec3(0.0), 0.99),

    // quad
    Material(vec3(0.7), 0.01, vec3(0.0), 0.99),

    // glass
    Material(vec3(0.7), 1.0, vec3(0.0), 0.0),

    // sphere1
    Material(vec3(0.7, 0.5, 0.1), 0.9, vec3(0.0), 0.9),

    // sphere2
    Material(vec3(0.9), 0.1, vec3(0.0), 0.0)
);

uint g_seed;

// https://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/
uint WangHash(inout uint seed)
{
    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
    seed *= uint(9);
    seed = seed ^ (seed >> 4);
    seed *= uint(0x27d4eb2d);
    seed = seed ^ (seed >> 15);
    return seed;
}

// random number between 0 and 1
float Random(inout uint state)
{
    return float(WangHash(state)) / 4294967296.0;
}

// random unit vector
vec3 RandomUnitVector(inout uint state)
{
    float z = Random(state) * 2.0 - 1.0;
    float a = Random(state) * TWO_PI;
    float r = sqrt(1.0 - z * z);
    float x = r * cos(a);
    float y = r * sin(a);
    return vec3(x, y, z);
}

float FresnelReflectAmount(float n1, float n2, vec3 normal, vec3 incident, float f0, float f90)
{
        // Schlick aproximation
        float r0 = (n1-n2) / (n1+n2);
        r0 *= r0;
        float cosX = -dot(normal, incident);
        if (n1 > n2)
        {
            float n = n1/n2;
            float sinT2 = n*n*(1.0-cosX*cosX);
            // Total internal reflection
            if (sinT2 > 1.0)
                return f90;
            cosX = sqrt(1.0-sinT2);
        }
        float x = 1.0 - cosX;
        float ret = r0 + (1.0 - r0) * x * x * x * x * x;

        // adjust reflect multiplier for object reflectivity
        return mix(f0, f90, ret);
}

//----------------------------------------------------------------------------//
//                              ray intersection
//----------------------------------------------------------------------------//

// https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle/moller-trumbore-ray-triangle-intersection
bool HitTriangle(inout Ray ray, in Triangle triangle)
{
    // P = A + u(B - A) + v(C - A) => O - A = -tD + u(B - A) + v(C - A)
    // -tD + uAB + vAC = AO
    vec3 AB = triangle.B - triangle.A;
    vec3 AC = triangle.C - triangle.A;

    vec3 P = cross(ray.direction, AC);
    float det = dot(AB, P);

    if (det < EPSILON)
        return false;

    float invDet = 1.0 / det;
    vec3 AO = ray.origin - triangle.A;

    vec3 Q = cross(AO, AB);
    float u = dot(AO, P) * invDet;
    float v = dot(ray.direction, Q) * invDet;

    if (u < 0.0 || v < 0.0 || u + v > 1.0)
        return false;

    float t = dot(AC, Q) * invDet;
    if (t >= ray.t || t < EPSILON)
        return false;

    ray.t = t;
    ray.hitNormal = normalize(cross(AB, AC));
    ray.material = triangle.material;

    return true;
}

bool HitSphere(inout Ray ray, in Sphere sphere)
{
    vec3 oc = ray.origin - sphere.center;
    float a = dot(ray.direction, ray.direction);
    float half_b = dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = half_b * half_b - a * c;

    float t = -half_b - sqrt(discriminant) / a;
    if (discriminant < EPSILON || t >= ray.t || t < EPSILON)
        return false;

    ray.t = t;
    vec3 p = ray.origin + t * ray.direction;
    ray.hitNormal = normalize(p - sphere.center);
    ray.material = sphere.material;

    return true;
}

vec3 RayColor(in Ray ray)
{
    vec3 radiance = vec3(0.0);
    vec3 throughput = vec3(1.0);

    for (int i = 0; i < MAX_BOUNCE; ++i)
    {
        for (int i = 0; i < TRIANGLE_COUNT; ++i)
        {
            HitTriangle(ray, g_triangles[i]);
        }

        for (int i = 0; i < SPHERE_COUNT; ++i)
        {
            HitSphere(ray, g_spheres[i]);
        }

        if (ray.t < RAY_T_MAX)
        {
            ray.origin = ray.origin + ray.t * ray.direction;
            ray.t = RAY_T_MAX;
            Material mat = g_materials[ray.material];
            float specularChance = Random(g_seed) > mat.reflectChance ? 0.0 : 1.0;

            vec3 diffuseDir = normalize(ray.hitNormal + RandomUnitVector(g_seed));
            vec3 reflectDir = reflect(ray.direction, ray.hitNormal);
            reflectDir = normalize(mix(reflectDir, diffuseDir, mat.roughness * mat.roughness));
            ray.direction = normalize(mix(diffuseDir, reflectDir, specularChance));

            radiance = mat.emissive * throughput;
            throughput *= mat.albedo;

            if (mat.emissive.r > 0.0)
                break;
        }
        else
        {
            // radiance += throughput * vec3(0.1);
            break;
        }
    }

    return radiance;
}

void main()
{
    // random seed
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    g_seed = uint(uint(pixel_coords.x) * uint(1973) + uint(pixel_coords.y) * uint(9277) + uint(random_seed0) * uint(26699)) | uint(1);

    ivec2 dims = imageSize(outImage);
    vec2 resolution = vec2(float(dims.x), float(dims.y));
    float u = (float(pixel_coords.x) + Random(g_seed)) / (resolution.x - 1.0);
    float v = (float(pixel_coords.y) + Random(g_seed)) / (resolution.y - 1.0);

    float cameraDistance = tan(1.0); // 60 degrees

    vec3 rayDirection = vec3(2.0 * vec2(u, v) - 1.0, -cameraDistance);
    float aspectRatio = resolution.x / resolution.y;
    rayDirection.y /= aspectRatio;

    Ray ray;
    ray.origin = camera_origin;
    ray.direction = normalize(rayDirection);
    ray.t = RAY_T_MAX;

    vec4 pixel = vec4(RayColor(ray), 1.0);

    vec4 colorSoFar = imageLoad(outImage, pixel_coords);

    imageStore(outImage, pixel_coords, pixel + colorSoFar);
}
